checking declaration
module Agda.Primitive where
  syntax Level ...
  postulate Level : Set
  {-# COMPILE GHC Level = type () #-}
  {-# BUILTIN LEVEL Level #-}
  syntax lzero ...
  postulate lzero : Level
  syntax lsuc ...
  postulate lsuc : (ℓ : Level) → Level
  infixl 6 _⊔_
  syntax _⊔_ ...
  postulate _⊔_ : (ℓ₁ ℓ₂ : Level) → Level
  {-# BUILTIN LEVELZERO lzero #-}
  {-# BUILTIN LEVELSUC lsuc #-}
  {-# BUILTIN LEVELMAX _⊔_ #-}
  module CubicalPrimitives where
    {-# BUILTIN INTERVAL I #-}
    {-# BUILTIN IZERO i0 #-}
    {-# BUILTIN IONE i1 #-}
    syntax primIMin ...
    primitive primIMin : I → I → I
    syntax primIMax ...
    primitive primIMax : I → I → I
    infix 30 primINeg
    syntax primINeg ...
    primitive primINeg : I → I
    {-# BUILTIN ISONE IsOne #-}
    syntax itIsOne ...
    postulate itIsOne : IsOne i1
    syntax IsOne1 ...
    postulate IsOne1 : ∀ i j → IsOne i → IsOne (primIMax i j)
    syntax IsOne2 ...
    postulate IsOne2 : ∀ i j → IsOne j → IsOne (primIMax i j)
    {-# BUILTIN ITISONE itIsOne #-}
    {-# BUILTIN ISONE1 IsOne1 #-}
    {-# BUILTIN ISONE2 IsOne2 #-}
    {-# BUILTIN PARTIAL Partial #-}
    {-# BUILTIN PARTIALP PartialP #-}
    syntax isOneEmpty ...
    postulate
      isOneEmpty : ∀ {a} {A : Partial (Set a) i0} → PartialP i0 A
    {-# BUILTIN ISONEEMPTY isOneEmpty #-}
    syntax primPFrom1 ...
    primitive
      primPFrom1 :
        ∀ {a} {A : I → Set a} → A i1 → ∀ i j → Partial (A (primIMax i j)) i
    syntax primPOr ...
    primitive
      primPOr :
        ∀ {a} (i j : I) {A : Partial (Set a) (primIMax i j)} →
        PartialP i (λ z → A (IsOne1 i j z)) →
        PartialP j (λ z → A (IsOne2 i j z)) → PartialP (primIMax i j) A
    syntax primComp ...
    primitive
      primComp :
        ∀ {a} (A : (i : I) → Set (a i)) (φ : I) →
        (∀ i → Partial (A i) φ) → (a₁ : A i0) → A i1
checking section Agda.Primitive
adding section: Agda.Primitive 0
    actual tele:
checking declaration
syntax Level ...
postulate Level : Set
checking declaration
syntax Level ...
postulate Level : Set
checked type signature Level : Set of sort  Set₁
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
checking declaration
{-# COMPILE GHC Level = type () #-}
checking declaration
{-# COMPILE GHC Level = type () #-}
checking declaration
{-# BUILTIN LEVEL Level #-}
checking declaration
{-# BUILTIN LEVEL Level #-}
{ checkExpr
inferred def  Level
   :  Set
   -->  Level
compareTerm Set =< Set : Set₁
Solving awake constraints. 0 remaining.
}
checking declaration
syntax lzero ...
postulate lzero : Level
checking declaration
syntax lzero ...
postulate lzero : Level
{ checkExpr
inferred def  Level
   :  Set
   -->  Level
term _0 :DirEq .#Lacking_Level_Builtins#
term _0 :DirEq .#Lacking_Level_Builtins#
solving _0 := .#Lacking_Level_Builtins#
compareTerm Set =< Set : Set₁
Solving awake constraints. 0 remaining.
}
checked type signature lzero : Level of sort  Set
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
checking declaration
syntax lsuc ...
postulate lsuc : (ℓ : Level) → Level
checking declaration
syntax lsuc ...
postulate lsuc : (ℓ : Level) → Level
{ checkExpr
inferred def  Level
   :  Set
   -->  Level
term _1 :DirEq .#Lacking_Level_Builtins#
term _1 :DirEq .#Lacking_Level_Builtins#
solving _1 := .#Lacking_Level_Builtins#
compareTerm Set =< Set : Set₁
Solving awake constraints. 0 remaining.
}
{ checkExpr
inferred def  Level
   :  Set
   -->  Level
term _2 ℓ :DirEq .#Lacking_Level_Builtins#
term _2 ℓ :DirEq .#Lacking_Level_Builtins#
solving _2 := λ ℓ → .#Lacking_Level_Builtins#
compareTerm Set =< Set : Set₁
Solving awake constraints. 0 remaining.
}
checked type signature lsuc : Level → Level of sort  Set
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
checking declaration
infixl 6 _⊔_
syntax _⊔_ ...
postulate _⊔_ : (ℓ₁ ℓ₂ : Level) → Level
checking declaration
infixl 6 _⊔_
syntax _⊔_ ...
postulate _⊔_ : (ℓ₁ ℓ₂ : Level) → Level
{ checkExpr
inferred def  Level
   :  Set
   -->  Level
term _3 :DirEq .#Lacking_Level_Builtins#
term _3 :DirEq .#Lacking_Level_Builtins#
solving _3 := .#Lacking_Level_Builtins#
compareTerm Set =< Set : Set₁
Solving awake constraints. 0 remaining.
}
{ checkExpr
inferred def  Level
   :  Set
   -->  Level
term _4 ℓ₁ ℓ₂ :DirEq .#Lacking_Level_Builtins#
term _4 ℓ₁ ℓ₂ :DirEq .#Lacking_Level_Builtins#
solving _4 := λ ℓ₁ ℓ₂ → .#Lacking_Level_Builtins#
compareTerm Set =< Set : Set₁
Solving awake constraints. 0 remaining.
}
checked type signature _⊔_ : Level → Level → Level of sort  Set
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
checking declaration
{-# BUILTIN LEVELZERO lzero #-}
checking declaration
{-# BUILTIN LEVELZERO lzero #-}
{ checkExpr
inferred def  lzero
   :  Level
   -->  lzero
coerce term      v  = lzero
       from type t1 = Level
       to type   t2 = Level
compareTerm Level =< Level : Set
Solving awake constraints. 0 remaining.
}
checking declaration
{-# BUILTIN LEVELSUC lsuc #-}
checking declaration
{-# BUILTIN LEVELSUC lsuc #-}
{ checkExpr
inferred def  lsuc
   :  Level → Level
   -->  lsuc
coerce term      v  = lsuc
       from type t1 = Level → Level
       to type   t2 = Level → Level
compareTerm Level → Level =< Level → Level : Set
Solving awake constraints. 0 remaining.
}
checking declaration
{-# BUILTIN LEVELMAX _⊔_ #-}
checking declaration
{-# BUILTIN LEVELMAX _⊔_ #-}
{ checkExpr
inferred def  _⊔_
   :  Level → Level → Level
   -->  _⊔_
coerce term      v  = _⊔_
       from type t1 = Level → Level → Level
       to type   t2 = Level → Level → Level
compareTerm Level → Level → Level =< Level → Level → Level : Set
Solving awake constraints. 0 remaining.
}
checking declaration
module CubicalPrimitives where
  {-# BUILTIN INTERVAL I #-}
  {-# BUILTIN IZERO i0 #-}
  {-# BUILTIN IONE i1 #-}
  syntax primIMin ...
  primitive primIMin : I → I → I
  syntax primIMax ...
  primitive primIMax : I → I → I
  infix 30 primINeg
  syntax primINeg ...
  primitive primINeg : I → I
  {-# BUILTIN ISONE IsOne #-}
  syntax itIsOne ...
  postulate itIsOne : IsOne i1
  syntax IsOne1 ...
  postulate IsOne1 : ∀ i j → IsOne i → IsOne (primIMax i j)
  syntax IsOne2 ...
  postulate IsOne2 : ∀ i j → IsOne j → IsOne (primIMax i j)
  {-# BUILTIN ITISONE itIsOne #-}
  {-# BUILTIN ISONE1 IsOne1 #-}
  {-# BUILTIN ISONE2 IsOne2 #-}
  {-# BUILTIN PARTIAL Partial #-}
  {-# BUILTIN PARTIALP PartialP #-}
  syntax isOneEmpty ...
  postulate
    isOneEmpty : ∀ {a} {A : Partial (Set a) i0} → PartialP i0 A
  {-# BUILTIN ISONEEMPTY isOneEmpty #-}
  syntax primPFrom1 ...
  primitive
    primPFrom1 :
      ∀ {a} {A : I → Set a} → A i1 → ∀ i j → Partial (A (primIMax i j)) i
  syntax primPOr ...
  primitive
    primPOr :
      ∀ {a} (i j : I) {A : Partial (Set a) (primIMax i j)} →
      PartialP i (λ z → A (IsOne1 i j z)) →
      PartialP j (λ z → A (IsOne2 i j z)) → PartialP (primIMax i j) A
  syntax primComp ...
  primitive
    primComp :
      ∀ {a} (A : (i : I) → Set (a i)) (φ : I) →
      (∀ i → Partial (A i) φ) → (a₁ : A i0) → A i1
checking declaration
module CubicalPrimitives where
  {-# BUILTIN INTERVAL I #-}
  {-# BUILTIN IZERO i0 #-}
  {-# BUILTIN IONE i1 #-}
  syntax primIMin ...
  primitive primIMin : I → I → I
  syntax primIMax ...
  primitive primIMax : I → I → I
  infix 30 primINeg
  syntax primINeg ...
  primitive primINeg : I → I
  {-# BUILTIN ISONE IsOne #-}
  syntax itIsOne ...
  postulate itIsOne : IsOne i1
  syntax IsOne1 ...
  postulate IsOne1 : ∀ i j → IsOne i → IsOne (primIMax i j)
  syntax IsOne2 ...
  postulate IsOne2 : ∀ i j → IsOne j → IsOne (primIMax i j)
  {-# BUILTIN ITISONE itIsOne #-}
  {-# BUILTIN ISONE1 IsOne1 #-}
  {-# BUILTIN ISONE2 IsOne2 #-}
  {-# BUILTIN PARTIAL Partial #-}
  {-# BUILTIN PARTIALP PartialP #-}
  syntax isOneEmpty ...
  postulate
    isOneEmpty : ∀ {a} {A : Partial (Set a) i0} → PartialP i0 A
  {-# BUILTIN ISONEEMPTY isOneEmpty #-}
  syntax primPFrom1 ...
  primitive
    primPFrom1 :
      ∀ {a} {A : I → Set a} → A i1 → ∀ i j → Partial (A (primIMax i j)) i
  syntax primPOr ...
  primitive
    primPOr :
      ∀ {a} (i j : I) {A : Partial (Set a) (primIMax i j)} →
      PartialP i (λ z → A (IsOne1 i j z)) →
      PartialP j (λ z → A (IsOne2 i j z)) → PartialP (primIMax i j) A
  syntax primComp ...
  primitive
    primComp :
      ∀ {a} (A : (i : I) → Set (a i)) (φ : I) →
      (∀ i → Partial (A i) φ) → (a₁ : A i0) → A i1
checking section CubicalPrimitives
adding section: CubicalPrimitives 0
    actual tele:
checking declaration
{-# BUILTIN INTERVAL I #-}
checking declaration
{-# BUILTIN INTERVAL I #-}
checking declaration
{-# BUILTIN IZERO i0 #-}
checking declaration
{-# BUILTIN IZERO i0 #-}
checking declaration
{-# BUILTIN IONE i1 #-}
checking declaration
{-# BUILTIN IONE i1 #-}
checking declaration
syntax primIMin ...
primitive primIMin : I → I → I
checking declaration
syntax primIMin ...
primitive primIMin : I → I → I
{ checkExpr
inferred def  I
   :  Setω
   -->  I
coerce term      v  = I
       from type t1 = Setω
       to type   t2 = Set _5
term _5 :DirEq Setω
term _5 :DirEq Setω
solving _5 := Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
inferred def  I
   :  Setω
   -->  I
coerce term      v  = I
       from type t1 = Setω
       to type   t2 = Set _6
term _6 :DirEq Setω
term _6 :DirEq Setω
solving _6 := Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
inferred def  I
   :  Setω
   -->  I
coerce term      v  = I
       from type t1 = Setω
       to type   t2 = Set _7
term _7 :DirEq Setω
term _7 :DirEq Setω
solving _7 := Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
compareTerm I → I → I = I → I → I : Setω
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
checking declaration
syntax primIMax ...
primitive primIMax : I → I → I
checking declaration
syntax primIMax ...
primitive primIMax : I → I → I
{ checkExpr
inferred def  I
   :  Setω
   -->  I
coerce term      v  = I
       from type t1 = Setω
       to type   t2 = Set _8
term _8 :DirEq Setω
term _8 :DirEq Setω
solving _8 := Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
inferred def  I
   :  Setω
   -->  I
coerce term      v  = I
       from type t1 = Setω
       to type   t2 = Set _9
term _9 :DirEq Setω
term _9 :DirEq Setω
solving _9 := Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
inferred def  I
   :  Setω
   -->  I
coerce term      v  = I
       from type t1 = Setω
       to type   t2 = Set _10
term _10 :DirEq Setω
term _10 :DirEq Setω
solving _10 := Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
compareTerm I → I → I = I → I → I : Setω
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
checking declaration
infix 30 primINeg
syntax primINeg ...
primitive primINeg : I → I
checking declaration
infix 30 primINeg
syntax primINeg ...
primitive primINeg : I → I
{ checkExpr
inferred def  I
   :  Setω
   -->  I
coerce term      v  = I
       from type t1 = Setω
       to type   t2 = Set _11
term _11 :DirEq Setω
term _11 :DirEq Setω
solving _11 := Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
inferred def  I
   :  Setω
   -->  I
coerce term      v  = I
       from type t1 = Setω
       to type   t2 = Set _12
term _12 :DirEq Setω
term _12 :DirEq Setω
solving _12 := Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
compareTerm I → I = I → I : Setω
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
checking declaration
{-# BUILTIN ISONE IsOne #-}
checking declaration
{-# BUILTIN ISONE IsOne #-}
checking declaration
syntax itIsOne ...
postulate itIsOne : IsOne i1
checking declaration
syntax itIsOne ...
postulate itIsOne : IsOne i1
{ checkExpr
inferred def  IsOne
   :  I → Setω
   -->  IsOne
{ checkExpr
coerce term      v  = i1
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
coerce term      v  = IsOne i1
       from type t1 = Setω
       to type   t2 = Set _13
term _13 :DirEq Setω
term _13 :DirEq Setω
solving _13 := Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
checked type signature itIsOne : IsOne i1 of sort  Setω
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
checking declaration
syntax IsOne1 ...
postulate IsOne1 : ∀ i j → IsOne i → IsOne (primIMax i j)
checking declaration
syntax IsOne1 ...
postulate IsOne1 : ∀ i j → IsOne i → IsOne (primIMax i j)
{ checkExpr
}
{ checkExpr
}
{ checkExpr
inferred def  IsOne
   :  (I → Setω)
   -->  IsOne
{ checkExpr
coerce term      v  = i
       from type t1 = _15
       to type   t2 = I
term _14 :DirEq Setω
term _14 :DirEq Setω
solving _14 := Setω
compareTerm _15 =< I : Setω
term _15 :DirLeq I
term _15 :DirLeq I
solving _15 := I
Solving awake constraints. 0 remaining.
}
coerce term      v  = IsOne i
       from type t1 = Setω
       to type   t2 = Set (_18 i j)
term _18 i j :DirEq Setω
term _18 i j :DirEq Setω
solving _18 := (λ i j → Setω)
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
inferred def  IsOne
   :  I → Setω
   -->  IsOne
{ checkExpr
inferred def  primIMax
   :  I → I → I
   -->  primIMax
{ checkExpr
coerce term      v  = i
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
coerce term      v  = j
       from type t1 = (_17 i)
       to type   t2 = I
term (_16 i) :DirEq Setω
term (_16 i) :DirEq Setω
solving _16 := λ i → Setω
compareTerm (_17 i) =< I : Setω
term (_17 i) :DirLeq I
term (_17 i) :DirLeq I
solving _17 := λ i → I
Solving awake constraints. 0 remaining.
}
coerce term      v  = primIMax i j
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
coerce term      v  = IsOne (primIMax i j)
       from type t1 = Setω
       to type   t2 = Set (_19 i j)
term _19 i j :DirEq Setω
term _19 i j :DirEq Setω
solving _19 := λ i j → Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
checked type signature
  IsOne1 : (i j : I) → IsOne i → IsOne (primIMax i j)
  of sort  Setω
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
checking declaration
syntax IsOne2 ...
postulate IsOne2 : ∀ i j → IsOne j → IsOne (primIMax i j)
checking declaration
syntax IsOne2 ...
postulate IsOne2 : ∀ i j → IsOne j → IsOne (primIMax i j)
{ checkExpr
}
{ checkExpr
}
{ checkExpr
inferred def  IsOne
   :  (I → Setω)
   -->  IsOne
{ checkExpr
coerce term      v  = j
       from type t1 = (_23 i)
       to type   t2 = I
term (_22 i) :DirEq Setω
term (_22 i) :DirEq Setω
solving _22 := (λ i → Setω)
compareTerm (_23 i) =< I : Setω
term (_23 i) :DirLeq I
term (_23 i) :DirLeq I
solving _23 := (λ i → I)
Solving awake constraints. 0 remaining.
}
coerce term      v  = IsOne j
       from type t1 = Setω
       to type   t2 = Set (_24 i j)
term _24 i j :DirEq Setω
term _24 i j :DirEq Setω
solving _24 := (λ i j → Setω)
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
inferred def  IsOne
   :  I → Setω
   -->  IsOne
{ checkExpr
inferred def  primIMax
   :  I → I → I
   -->  primIMax
{ checkExpr
coerce term      v  = i
       from type t1 = _21
       to type   t2 = I
term _20 :DirEq Setω
term _20 :DirEq Setω
solving _20 := Setω
compareTerm _21 =< I : Setω
term _21 :DirLeq I
term _21 :DirLeq I
solving _21 := I
Solving awake constraints. 0 remaining.
}
{ checkExpr
coerce term      v  = j
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
coerce term      v  = primIMax i j
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
coerce term      v  = IsOne (primIMax i j)
       from type t1 = Setω
       to type   t2 = Set (_25 i j)
term _25 i j :DirEq Setω
term _25 i j :DirEq Setω
solving _25 := λ i j → Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
checked type signature
  IsOne2 : (i j : I) → IsOne j → IsOne (primIMax i j)
  of sort  Setω
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
checking declaration
{-# BUILTIN ITISONE itIsOne #-}
checking declaration
{-# BUILTIN ITISONE itIsOne #-}
{ checkExpr
inferred def  itIsOne
   :  IsOne i1
   -->  itIsOne
coerce term      v  = itIsOne
       from type t1 = IsOne i1
       to type   t2 = IsOne i1
compareTerm IsOne i1 =< IsOne i1 : Setω
Solving awake constraints. 0 remaining.
}
checking declaration
{-# BUILTIN ISONE1 IsOne1 #-}
checking declaration
{-# BUILTIN ISONE1 IsOne1 #-}
{ checkExpr
inferred def  IsOne1
   :  (i j : I) → IsOne i → IsOne (primIMax i j)
   -->  IsOne1
coerce term      v  = IsOne1
       from type t1 = (i j : I) → IsOne i → IsOne (primIMax i j)
       to type   t2 = (i j : I) (i2 : IsOne i) → IsOne (primIMax i j)
compareTerm
  (i j : I) → IsOne i → IsOne (primIMax i j) =< (i j : I)
                                                (i2 : IsOne i) →
                                                IsOne (primIMax i j)
  : Setω
Solving awake constraints. 0 remaining.
}
checking declaration
{-# BUILTIN ISONE2 IsOne2 #-}
checking declaration
{-# BUILTIN ISONE2 IsOne2 #-}
{ checkExpr
inferred def  IsOne2
   :  (i j : I) → IsOne j → IsOne (primIMax i j)
   -->  IsOne2
coerce term      v  = IsOne2
       from type t1 = (i j : I) → IsOne j → IsOne (primIMax i j)
       to type   t2 = (i j : I) (j1 : IsOne j) → IsOne (primIMax i j)
compareTerm
  (i j : I) → IsOne j → IsOne (primIMax i j) =< (i j : I)
                                                (j1 : IsOne j) →
                                                IsOne (primIMax i j)
  : Setω
Solving awake constraints. 0 remaining.
}
checking declaration
{-# BUILTIN PARTIAL Partial #-}
checking declaration
{-# BUILTIN PARTIAL Partial #-}
checking declaration
{-# BUILTIN PARTIALP PartialP #-}
checking declaration
{-# BUILTIN PARTIALP PartialP #-}
checking declaration
syntax isOneEmpty ...
postulate
  isOneEmpty : ∀ {a} {A : Partial (Set a) i0} → PartialP i0 A
checking declaration
syntax isOneEmpty ...
postulate
  isOneEmpty : ∀ {a} {A : Partial (Set a) i0} → PartialP i0 A
{ checkExpr
}
{ checkExpr
inferred def  Partial
   :  {a = a₁ : Level} (A : Set a₁) → I → Setω
   -->  Partial
{ checkExpr
{ checkExpr
coerce term      v  = a
       from type t1 = _27
       to type   t2 = Level
term _26 :DirEq lzero
term _26 :DirEq lzero
solving _26 := lzero
compareTerm _27 =< Level : Set
term _27 :DirLeq Level
term _27 :DirLeq Level
solving _27 := Level
Solving awake constraints. 0 remaining.
}
checking Set  a against Set _a_29
term _a_29 :DirEq lsuc a
term _a_29 :DirEq lsuc a
solving _a_29 := λ {a} → lsuc a
compareTerm Set (lsuc a) =< Set (lsuc a) : Set (lsuc (lsuc a))
Solving awake constraints. 0 remaining.
}
{ checkExpr
coerce term      v  = i0
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
coerce term      v  = Partial (Set a) i0
       from type t1 = Setω
       to type   t2 = Set _28
term _28 :DirEq Setω
term _28 :DirEq Setω
solving _28 := λ {a} → Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
inferred def  PartialP
   :  {a = a₁ : Level} (φ : I) (A₁ : .(o : IsOne φ) → Set a₁) → Setω
   -->  PartialP
{ checkExpr
coerce term      v  = i0
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
coerce term      v  = A
       from type t1 = (.(IsOne i0) → Set a)
       to type   t2 = (.(o : IsOne i0) → Set _a_31)
compareTerm
  (.(IsOne i0) → Set a) =< (.(o : IsOne i0) → Set _a_31)
  : Setω
compareTerm (IsOne i0) =< (IsOne i0) : Setω
term _a_31 :DirEq a
term _a_31 :DirEq a
solving _a_31 := λ {a} {A} → a
compareTerm (Set a) =< (Set a) : (Set (lsuc a))
Solving awake constraints. 0 remaining.
}
coerce term      v  = PartialP i0 A
       from type t1 = Setω
       to type   t2 = Set _30
term _30 :DirEq Setω
term _30 :DirEq Setω
solving _30 := λ {a} {A} → Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
checked type signature
  isOneEmpty : {a : Level} {A : Partial (Set a) i0} → PartialP i0 A
  of sort  Setω
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
checking declaration
{-# BUILTIN ISONEEMPTY isOneEmpty #-}
checking declaration
{-# BUILTIN ISONEEMPTY isOneEmpty #-}
{ checkExpr
{ checkExpr
checking that  Level  is not an empty type of sizes
Solving awake constraints. 0 remaining.
{ checkExpr
{ checkExpr
checking that  .(o : IsOne i0) →
               Set .l  is not an empty type of sizes
in context  {.l : Level}
Solving awake constraints. 0 remaining.
{ checkExpr
inferred def  isOneEmpty
   :  {a : Level} {A : Partial (Set a) i0} → PartialP i0 A
   -->  isOneEmpty
coerce term      v  = isOneEmpty
       from type t1 = .(p : IsOne i0) → _A_33 p
       to type   t2 = .(o : IsOne i0) → .A _
compareTerm
  .(p : IsOne i0) → _A_33 p =< .(o : IsOne i0) → .A _
  : Setω
compareTerm IsOne i0 =< IsOne i0 : Setω
term _a_32 :DirEq .l
term _a_32 :DirEq .l
solving _a_32 := λ {.l} {.A} → .l
compareTerm _A_33 p =< .A _ : Set .l
term _A_33 p :DirLeq .A _
term _A_33 p :DirLeq .A _
solving _A_33 := λ {.l} {.A} .z → .A _
Solving awake constraints. 0 remaining.
}
}
}
}
}
checking declaration
syntax primPFrom1 ...
primitive
  primPFrom1 :
    ∀ {a} {A : I → Set a} → A i1 → ∀ i j → Partial (A (primIMax i j)) i
checking declaration
syntax primPFrom1 ...
primitive
  primPFrom1 :
    ∀ {a} {A : I → Set a} → A i1 → ∀ i j → Partial (A (primIMax i j)) i
{ checkExpr
}
{ checkExpr
inferred def  I
   :  Setω
   -->  I
coerce term      v  = I
       from type t1 = Setω
       to type   t2 = Set _36
term _36 :DirEq Setω
term _36 :DirEq Setω
solving _36 := (λ {a} → Setω)
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
coerce term      v  = a
       from type t1 = _35
       to type   t2 = Level
term _34 :DirEq lzero
term _34 :DirEq lzero
solving _34 := lzero
compareTerm _35 =< Level : Set
term _35 :DirLeq Level
term _35 :DirLeq Level
solving _35 := Level
Solving awake constraints. 0 remaining.
}
{ checkExpr
{ checkExpr
coerce term      v  = i1
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
term _37 :DirEq a
term _37 :DirEq a
solving _37 := (λ {a} {A} → a)
compareTerm Set a =< Set a : Set (lsuc a)
Solving awake constraints. 0 remaining.
}
{ checkExpr
}
{ checkExpr
}
{ checkExpr
inferred def  Partial
   :  {a = a₁ : Level} (A₁ : Set a₁) → I → Setω
   -->  Partial
{ checkExpr
{ checkExpr
inferred def  primIMax
   :  I → I → I
   -->  primIMax
{ checkExpr
coerce term      v  = i
       from type t1 = _39
       to type   t2 = I
term _38 :DirEq Setω
term _38 :DirEq Setω
solving _38 := (λ {a} {A} → Setω)
compareTerm _39 =< I : Setω
term _39 :DirLeq I
term _39 :DirLeq I
solving _39 := (λ {a} {A} → I)
Solving awake constraints. 0 remaining.
}
{ checkExpr
coerce term      v  = j
       from type t1 = (_41 i)
       to type   t2 = I
term (_40 i) :DirEq Setω
term (_40 i) :DirEq Setω
solving _40 := λ {a} {A} i → Setω
compareTerm (_41 i) =< I : Setω
term (_41 i) :DirLeq I
term (_41 i) :DirLeq I
solving _41 := λ {a} {A} i → I
Solving awake constraints. 0 remaining.
}
coerce term      v  = primIMax i j
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
term _a_43 i j :DirEq a
term _a_43 i j :DirEq a
solving _a_43 := λ {a} {A} i j → a
compareTerm Set a =< Set a : Set (lsuc a)
Solving awake constraints. 0 remaining.
}
{ checkExpr
coerce term      v  = i
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
coerce term      v  = Partial (A (primIMax i j)) i
       from type t1 = Setω
       to type   t2 = Set (_42 i j)
term _42 i j :DirEq Setω
term _42 i j :DirEq Setω
solving _42 := λ {a} {A} i j → Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
compareTerm
  {a : Level} {A : I → Set a} →
  A i1 → (i j : I) → Partial (A (primIMax i j)) i = {a : Level}
                                                    {A : I → Set a} →
                                                    A i1 →
                                                    (i j : I) .(o : IsOne i) → A (primIMax i j)
  : Setω
compareTerm Level = Level : Set
compareTerm
  {A : I → Set a} →
  A i1 → (i j : I) → Partial (A (primIMax i j)) i = {A : I → Set a} →
                                                    A i1 →
                                                    (i j : I) .(o : IsOne i) → A (primIMax i j)
  : Setω
compareTerm I → Set a = I → Set a : Setω
compareTerm I = I : Setω
compareTerm Set a = Set a : Set (lsuc a)
compareTerm
  A i1 → (i j : I) → Partial (A (primIMax i j)) i = A i1 →
                                                    (i j : I) .(o : IsOne i) → A (primIMax i j)
  : Setω
compareTerm A i1 = A i1 : Set a
compareTerm
  (i j : I) → Partial (A (primIMax i j)) i = (i j : I)
                                             .(o : IsOne i) →
                                             A (primIMax i j)
  : Setω
compareTerm I = I : Setω
compareTerm
  (j : I) → Partial (A (primIMax i j)) i = (j : I) .(o : IsOne i) →
                                           A (primIMax i j)
  : Setω
compareTerm I = I : Setω
compareTerm
  Partial (A (primIMax i j)) i = .(o : IsOne i) → A (primIMax i j)
  : Setω
compareTerm IsOne i = IsOne i : Setω
compareTerm A (primIMax i j) = A (primIMax i j) : Set a
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
checking declaration
syntax primPOr ...
primitive
  primPOr :
    ∀ {a} (i j : I) {A : Partial (Set a) (primIMax i j)} →
    PartialP i (λ z → A (IsOne1 i j z)) →
    PartialP j (λ z → A (IsOne2 i j z)) → PartialP (primIMax i j) A
checking declaration
syntax primPOr ...
primitive
  primPOr :
    ∀ {a} (i j : I) {A : Partial (Set a) (primIMax i j)} →
    PartialP i (λ z → A (IsOne1 i j z)) →
    PartialP j (λ z → A (IsOne2 i j z)) → PartialP (primIMax i j) A
{ checkExpr
}
{ checkExpr
inferred def  I
   :  Setω
   -->  I
coerce term      v  = I
       from type t1 = Setω
       to type   t2 = Set _46
term _46 :DirEq Setω
term _46 :DirEq Setω
solving _46 := λ {a} → Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
inferred def  Partial
   :  {a = a₁ : Level} (A : Set a₁) → I → Setω
   -->  Partial
{ checkExpr
{ checkExpr
coerce term      v  = a
       from type t1 = _45
       to type   t2 = Level
term _44 :DirEq lzero
term _44 :DirEq lzero
solving _44 := lzero
compareTerm _45 =< Level : Set
term _45 :DirLeq Level
term _45 :DirLeq Level
solving _45 := Level
Solving awake constraints. 0 remaining.
}
checking Set  a against Set (_a_48 i j)
term _a_48 i j :DirEq lsuc a
term _a_48 i j :DirEq lsuc a
solving _a_48 := λ {a} i j → lsuc a
compareTerm Set (lsuc a) =< Set (lsuc a) : Set (lsuc (lsuc a))
Solving awake constraints. 0 remaining.
}
{ checkExpr
inferred def  primIMax
   :  I → I → I
   -->  primIMax
{ checkExpr
coerce term      v  = i
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
coerce term      v  = j
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
coerce term      v  = primIMax i j
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
coerce term      v  = Partial (Set a) (primIMax i j)
       from type t1 = Setω
       to type   t2 = Set (_47 i j)
term _47 i j :DirEq Setω
term _47 i j :DirEq Setω
solving _47 := λ {a} i j → Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
inferred def  PartialP
   :  ({a = a₁ : Level} (φ : I) (A₁ : .(o : IsOne φ) → Set a₁) →
       Setω)
   -->  PartialP
{ checkExpr
coerce term      v  = i
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
checking that  IsOne i  is not an empty type of sizes
in context  {a : Level} (i : I) (j : I)
            {A : Partial (Set a) (primIMax i j)}
Solving awake constraints. 0 remaining.
{ checkExpr
{ checkExpr
inferred def  IsOne1
   :  (i₁ j₁ : I) → IsOne i₁ → IsOne (primIMax i₁ j₁)
   -->  IsOne1
{ checkExpr
coerce term      v  = i
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
coerce term      v  = j
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
coerce term      v  = z
       from type t1 = (IsOne i)
       to type   t2 = (IsOne i)
compareTerm (IsOne i) =< (IsOne i) : Setω
Solving awake constraints. 0 remaining.
}
coerce term      v  = IsOne1 i j z
       from type t1 = IsOne (primIMax i j)
       to type   t2 = IsOne (primIMax i j)
compareTerm IsOne (primIMax i j) =< IsOne (primIMax i j) : Setω
Solving awake constraints. 0 remaining.
}
term _a_50 i j :DirEq a
term _a_50 i j :DirEq a
solving _a_50 := λ {a} i j {A} → a
compareTerm Set a =< Set a : Set (lsuc a)
Solving awake constraints. 0 remaining.
}
}
coerce term      v  = PartialP i (λ .z → A _)
       from type t1 = Setω
       to type   t2 = Set (_49 i j)
term _49 i j :DirEq Setω
term _49 i j :DirEq Setω
solving _49 := (λ {a} i j {A} → Setω)
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
inferred def  PartialP
   :  ({a = a₁ : Level} (φ : I) (A₁ : .(o : IsOne φ) → Set a₁) →
       Setω)
   -->  PartialP
{ checkExpr
coerce term      v  = j
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
checking that  IsOne j  is not an empty type of sizes
in context  {a : Level} (i : I) (j : I)
            {A : Partial (Set a) (primIMax i j)}
Solving awake constraints. 0 remaining.
{ checkExpr
{ checkExpr
inferred def  IsOne2
   :  (i₁ j₁ : I) → IsOne j₁ → IsOne (primIMax i₁ j₁)
   -->  IsOne2
{ checkExpr
coerce term      v  = i
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
coerce term      v  = j
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
coerce term      v  = z
       from type t1 = (IsOne j)
       to type   t2 = (IsOne j)
compareTerm (IsOne j) =< (IsOne j) : Setω
Solving awake constraints. 0 remaining.
}
coerce term      v  = IsOne2 i j z
       from type t1 = IsOne (primIMax i j)
       to type   t2 = IsOne (primIMax i j)
compareTerm IsOne (primIMax i j) =< IsOne (primIMax i j) : Setω
Solving awake constraints. 0 remaining.
}
term _a_52 i j :DirEq a
term _a_52 i j :DirEq a
solving _a_52 := λ {a} i j {A} → a
compareTerm Set a =< Set a : Set (lsuc a)
Solving awake constraints. 0 remaining.
}
}
coerce term      v  = PartialP j (λ .z → A _)
       from type t1 = Setω
       to type   t2 = Set (_51 i j)
term _51 i j :DirEq Setω
term _51 i j :DirEq Setω
solving _51 := (λ {a} i j {A} → Setω)
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
inferred def  PartialP
   :  {a = a₁ : Level} (φ : I) (A₁ : .(o : IsOne φ) → Set a₁) → Setω
   -->  PartialP
{ checkExpr
inferred def  primIMax
   :  I → I → I
   -->  primIMax
{ checkExpr
coerce term      v  = i
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
coerce term      v  = j
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
coerce term      v  = primIMax i j
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
coerce term      v  = A
       from type t1 = (.(IsOne (primIMax i j)) → Set a)
       to type   t2 = (.(o : IsOne (primIMax i j)) → Set (_a_54 i j))
compareTerm
  (.(IsOne (primIMax i j)) → Set a) =< (.(o : IsOne (primIMax i j)) →
                                        Set (_a_54 i j))
  : Setω
compareTerm (IsOne (primIMax i j)) =< (IsOne (primIMax i j)) : Setω
term (_a_54 i j) :DirEq a
term (_a_54 i j) :DirEq a
solving _a_54 := λ {a} i j {A} → a
compareTerm (Set a) =< (Set a) : (Set (lsuc a))
Solving awake constraints. 0 remaining.
}
coerce term      v  = PartialP (primIMax i j) A
       from type t1 = Setω
       to type   t2 = Set (_53 i j)
term _53 i j :DirEq Setω
term _53 i j :DirEq Setω
solving _53 := λ {a} i j {A} → Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
compareTerm
  {a : Level} (i j : I) {A : Partial (Set a) (primIMax i j)} →
  PartialP i (λ .z → A _) →
  PartialP j (λ .z → A _) → PartialP (primIMax i j) A = {a : Level}
                                                        (i j : I)
                                                        {A : .(o : IsOne (primIMax i j)) → Set a} →
                                                        (.(i2 : IsOne i) → A _) →
                                                        (.(j1 : IsOne j) → A _) →
                                                        .(o : IsOne (primIMax i j)) → A _
  : Setω
compareTerm Level = Level : Set
compareTerm
  (i j : I) {A : Partial (Set a) (primIMax i j)} →
  PartialP i (λ .z → A _) →
  PartialP j (λ .z → A _) → PartialP (primIMax i j) A = (i j : I)
                                                        {A : .(o : IsOne (primIMax i j)) → Set a} →
                                                        (.(i2 : IsOne i) → A _) →
                                                        (.(j1 : IsOne j) → A _) →
                                                        .(o : IsOne (primIMax i j)) → A _
  : Setω
compareTerm I = I : Setω
compareTerm
  (j : I) {A : Partial (Set a) (primIMax i j)} →
  PartialP i (λ .z → A _) →
  PartialP j (λ .z → A _) → PartialP (primIMax i j) A = (j : I)
                                                        {A : .(o : IsOne (primIMax i j)) → Set a} →
                                                        (.(i2 : IsOne i) → A _) →
                                                        (.(j1 : IsOne j) → A _) →
                                                        .(o : IsOne (primIMax i j)) → A _
  : Setω
compareTerm I = I : Setω
compareTerm
  {A : Partial (Set a) (primIMax i j)} →
  PartialP i (λ .z → A _) →
  PartialP j (λ .z → A _) → PartialP (primIMax i j) A = {A
                                                         : .(o : IsOne (primIMax i j)) → Set a} →
                                                        (.(i2 : IsOne i) → A _) →
                                                        (.(j1 : IsOne j) → A _) →
                                                        .(o : IsOne (primIMax i j)) → A _
  : Setω
compareTerm
  .(o : IsOne (primIMax i j)) → Set a = Partial (Set a)
                                        (primIMax i j)
  : Setω
compareTerm IsOne (primIMax i j) = IsOne (primIMax i j) : Setω
compareTerm Set a = Set a : Set (lsuc a)
compareTerm
  PartialP i (λ .z → A _) →
  PartialP j (λ .z → A _) → PartialP (primIMax i j) A = (.(i2
                                                           : IsOne i) →
                                                         A _) →
                                                        (.(j1 : IsOne j) → A _) →
                                                        .(o : IsOne (primIMax i j)) → A _
  : Setω
compareTerm .(i2 : IsOne i) → A _ = PartialP i (λ .z → A _) : Setω
compareTerm IsOne i = IsOne i : Setω
compareTerm A _ = A _ : Set a
compareTerm
  PartialP j (λ .z → A _) → PartialP (primIMax i j) A = (.(j1
                                                           : IsOne j) →
                                                         A _) →
                                                        .(o : IsOne (primIMax i j)) → A _
  : Setω
compareTerm .(j1 : IsOne j) → A _ = PartialP j (λ .z → A _) : Setω
compareTerm IsOne j = IsOne j : Setω
compareTerm A _ = A _ : Set a
compareTerm
  PartialP (primIMax i j) A = .(o : IsOne (primIMax i j)) → A _
  : Setω
compareTerm IsOne (primIMax i j) = IsOne (primIMax i j) : Setω
compareTerm A p = A _ : Set a
  a    = .(o : IsOne (primIMax i j)) → Set a
  v    = A
  arg1 = p
  arg2 = _
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
checking declaration
syntax primComp ...
primitive
  primComp :
    ∀ {a} (A : (i : I) → Set (a i)) (φ : I) →
    (∀ i → Partial (A i) φ) → (a₁ : A i0) → A i1
checking declaration
syntax primComp ...
primitive
  primComp :
    ∀ {a} (A : (i : I) → Set (a i)) (φ : I) →
    (∀ i → Partial (A i) φ) → (a₁ : A i0) → A i1
{ checkExpr
}
{ checkExpr
inferred def  I
   :  Setω
   -->  I
coerce term      v  = I
       from type t1 = Setω
       to type   t2 = Set _57
term _57 :DirEq Setω
term _57 :DirEq Setω
solving _57 := λ {a} → Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 0 remaining.
}
{ checkExpr
}
{ checkExpr
inferred def  I
   :  Setω
   -->  I
coerce term      v  = I
       from type t1 = Setω
       to type   t2 = Set (_60 A)
term _60 A :DirEq Setω
term _60 A :DirEq Setω
solving _60 := λ {a} A → Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 1 remaining.
Solving awake constraints. 0 remaining.
}
{ checkExpr
}
{ checkExpr
inferred def  Partial
   :  {a = a₁ : Level} (A₁ : Set a₁) → I → Setω
   -->  Partial
{ checkExpr
{ checkExpr
coerce term      v  = i
       from type t1 = (_62 A φ)
       to type   t2 = I
term (_61 A φ) :DirEq Setω
term (_61 A φ) :DirEq Setω
solving _61 := λ {a} A φ → Setω
compareTerm (_62 A φ) =< I : Setω
term (_62 A φ) :DirLeq I
term (_62 A φ) :DirLeq I
solving _62 := λ {a} A φ → I
Solving awake constraints. 1 remaining.
Solving awake constraints. 0 remaining.
}
term _a_64 A φ i :DirEq _59 i
term _a_64 A φ i :DirEq _59 i
solving _a_64 := λ {a} A φ i → _59 i
compareTerm Set (_59 i) =< Set (_59 i) : Set (lsuc (_59 i))
Solving awake constraints. 1 remaining.
Solving awake constraints. 0 remaining.
}
{ checkExpr
coerce term      v  = φ
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
coerce term      v  = Partial (A i) φ
       from type t1 = Setω
       to type   t2 = Set (_63 A φ i)
term _63 A φ i :DirEq Setω
term _63 A φ i :DirEq Setω
solving _63 := λ {a} A φ i → Setω
compareTerm Setω =< Setω : Setω
Solving awake constraints. 1 remaining.
Solving awake constraints. 0 remaining.
}
{ checkExpr
{ checkExpr
coerce term      v  = i0
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
term _65 A φ :DirEq _59 i0
term _65 A φ :DirEq _59 i0
solving _65 := λ {a} A φ → _59 i0
compareTerm Set (_59 i0) =< Set (_59 i0) : Set (lsuc (_59 i0))
Solving awake constraints. 1 remaining.
Solving awake constraints. 0 remaining.
}
{ checkExpr
{ checkExpr
coerce term      v  = i1
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
term _66 A φ a :DirEq _59 i1
term _66 A φ a :DirEq _59 i1
solving _66 := λ {a} A φ a₁ → _59 i1
compareTerm Set (_59 i1) =< Set (_59 i1) : Set (lsuc (_59 i1))
Solving awake constraints. 1 remaining.
Solving awake constraints. 0 remaining.
}
compareTerm
  {a : _56} (A : (i : I) → Set (_59 i)) (φ : I) →
  ((i : I) → Partial (A i) φ) → A i0 → A i1 = {a : I → Level}
                                              (A : (i : I) → Set (a i)) (φ : I) →
                                              ((i : I) .(o : IsOne φ) → A i) → A i0 → A i1
  : Setω
term _55 :DirEq Setω
term _55 :DirEq Setω
solving _55 := Setω
compareTerm I → Level = _56 : Setω
term _56 :DirEq I → Level
term _56 :DirEq I → Level
solving _56 := I → Level
compareTerm
  (A : (i : I) → Set (_59 i)) (φ : I) →
  ((i : I) → Partial (A i) φ) → A i0 → A i1 = (A
                                               : (i : I) → Set (a i))
                                              (φ : I) →
                                              ((i : I) .(o : IsOne φ) → A i) → A i0 → A i1
  : Setω
compareTerm (i : I) → Set (a i) = (i : I) → Set (_59 i) : Setω
compareTerm I = I : Setω
term _59 i :DirEq a i
term _59 i :DirEq a i
solving _59 := λ {a} i → a i
compareTerm Set (a i) = Set (a i) : Set (lsuc (a i))
compareTerm
  (φ : I) → ((i : I) → Partial (A i) φ) → A i0 → A i1 = (φ : I) →
                                                        ((i : I) .(o : IsOne φ) → A i) → A i0 → A i1
  : Setω
compareTerm I = I : Setω
compareTerm
  ((i : I) → Partial (A i) φ) → A i0 → A i1 = ((i : I)
                                               .(o : IsOne φ) →
                                               A i) →
                                              A i0 → A i1
  : Setω
compareTerm
  (i : I) .(o : IsOne φ) → A i = (i : I) → Partial (A i) φ
  : Setω
compareTerm I = I : Setω
compareTerm .(o : IsOne φ) → A i = Partial (A i) φ : Setω
compareTerm IsOne φ = IsOne φ : Setω
compareTerm A i = A i : Set (a i)
compareTerm A i0 → A i1 = A i0 → A i1 : Set (a i0 ⊔ a i1)
Solving awake constraints. 1 remaining.
{ checkExpr
coerce term      v  = i
       from type t1 = I
       to type   t2 = I
compareTerm I =< I : Setω
Solving awake constraints. 0 remaining.
}
coerce term      v  = a i
       from type t1 = Level
       to type   t2 = Level
compareTerm Level =< Level : Set
Solving awake constraints. 0 remaining.
Solving awake constraints. 1 remaining.
compareTerm a i = a i : Level
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
Removed 0 unused definitions.
checking declaration
module Issue2754 where
checking section Issue2754
adding section: Issue2754 0
    actual tele:
Solving awake constraints. 0 remaining.
Solving awake constraints. 0 remaining.
Removed 0 unused definitions.
